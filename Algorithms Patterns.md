https://www.linkedin.com/feed/update/urn:li:activity:7232608445898612737/
15 Must-Know LeetCode Patterns for Coding Interviews:  
  
1. 𝐏𝐫𝐞𝐟𝐢𝐱 𝐒𝐮𝐦: Precomputes cumulative sums up to each index of an array.  
	- Used to efficiently compute range sums.  
  
2. 𝐓𝐰𝐨 𝐏𝐨𝐢𝐧𝐭𝐞𝐫𝐬: Uses two pointers to traverse data structures.  
	- Used to optimize problems involving pairs in a sorted array or linked lists.  
  
3. 𝐒𝐥𝐢𝐝𝐢𝐧𝐠 𝐖𝐢𝐧𝐝𝐨𝐰: Maintains a window of elements, slides over it and updates the result.  
	- Used to find subarrays or substrings that meet certain conditions.  
  
4. 𝐅𝐚𝐬𝐭 & 𝐒𝐥𝐨𝐰 𝐏𝐨𝐢𝐧𝐭𝐞𝐫𝐬: Moves two pointers at different speeds.  
	- Used to detect cycles in linked lists or arrays, find middle elements.  
  
5. 𝐋𝐢𝐧𝐤𝐞𝐝𝐋𝐢𝐬𝐭 𝐈𝐧-𝐩𝐥𝐚𝐜𝐞 𝐑𝐞𝐯𝐞𝐫𝐬𝐚𝐥: Reverses a linked list or its parts without extra space.  
	- Used to modify linked lists in-place, often in problems involving reversals or reordering of nodes.  
  
6. 𝐌𝐨𝐧𝐨𝐭𝐨𝐧𝐢𝐜 𝐒𝐭𝐚𝐜𝐤: Maintains a stack in increasing or decreasing order of elements.  
	- Used for problems involving next/previous greater/smaller elements.  
  
7. 𝐓𝐨𝐩 ‘𝐊’ 𝐄𝐥𝐞𝐦𝐞𝐧𝐭𝐬: Uses a heap to keep track of the top 'K' elements.  
	- Used to find the most/least frequent elements, largest/smallest 'K' values..  
  
8. 𝐎𝐯𝐞𝐫𝐥𝐚𝐩𝐩𝐢𝐧𝐠 𝐈𝐧𝐭𝐞𝐫𝐯𝐚𝐥𝐬: Works by sorting intervals, iterating through them, merging or processing as needed.  
	- Used to merge intervals, handle bookings or events.  
  
9. 𝐌𝐨𝐝𝐢𝐟𝐢𝐞𝐝 𝐁𝐢𝐧𝐚𝐫𝐲 𝐒𝐞𝐚𝐫𝐜𝐡: Works by applying binary search logic with modifications.  
	- Used to solve problems like searching in rotated arrays, finding peaks.  
  
10. 𝐁𝐢𝐧𝐚𝐫𝐲 𝐓𝐫𝐞𝐞 𝐓𝐫𝐚𝐯𝐞𝐫𝐬𝐚𝐥: Works by recursively or iteratively visiting tree nodes in the required order (inorder, preorder, postorder).  
	- Used to explore or process tree nodes systematically.  
  
11. 𝐃𝐞𝐩𝐭𝐡-𝐅𝐢𝐫𝐬𝐭 𝐒𝐞𝐚𝐫𝐜𝐡 (𝐃𝐅𝐒): Explores all nodes/paths in depth before breadth.  
	- Used for tree or graph traversal where all paths need exploration.  
  
12. 𝐁𝐫𝐞𝐚𝐝𝐭𝐡-𝐅𝐢𝐫𝐬𝐭 𝐒𝐞𝐚𝐫𝐜𝐡 (𝐁𝐅𝐒): Uses a queue to visit all neighbors of a node before moving to the next level.  
	- Used to find shortest paths, level-order processing, or when solution is close to source.  
  
13. 𝐌𝐚𝐭𝐫𝐢𝐱 𝐓𝐫𝐚𝐯𝐞𝐫𝐬𝐚𝐥: Works by navigating through a matrix in a specific direction/order.  
	- Used to solve 2D grid-based problems.  
  
14. 𝐁𝐚𝐜𝐤𝐭𝐫𝐚𝐜𝐤𝐢𝐧𝐠: Works by recursively trying all options and backtracking when you hit a dead end.  
	- Used to solve combinatorial problems, like generating permutations, combinations or solving puzzles.  
  
15. 𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠: Breaks problems into overlapping subproblems, solve them optimally, store solutions to subproblems and reuse them to solve larger problems.  
	- Used to solve problems with optimal substructure and overlapping subproblems, like knapsack, LIS.